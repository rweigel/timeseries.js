<!DOCTYPE html>
<head>
	<title>Timeseries.js</title>
  <script
    type="text/javascript"
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script> 
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="util.js"></script>
	<script src="timeseries.js"></script>
	<script src="log.js"></script>
	<script src="events.js"></script>
  <style>
    htm, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    div.plotly-notifier {
      visibility: hidden;
    }
  </style>
</head>

<body>
	<div id="plot0"/>
</body>

<script>
const x = [0, 1, 2, 3, 4, 5];
const y = [0, 1, 2, 3, 4, 5];
const style = {name: 'name1', showlegend: false};
plot(x, y, style)

function last(array) {
  return array[array.length - 1]
}

function getMajorTicks(id, direction) {
  const axisName = direction + 'axis'
  const domElement = document.getElementById(id);
  const _axis = domElement._fullLayout[axisName];

  let values = [];
  for (let _val of _axis._vals) {
    if (!_val.minor) values.push(_val.x)
  }
  return values
}

function getMinorTicks(id, direction) {
  const axisName = direction + 'axis'
  const domElement = document.getElementById(id);
  const _axis = domElement._fullLayout[axisName];

  let values = [];
  for (let _val of _axis._vals) {
    if (_val.minor) values.push(_val.x)
  }
  return values
}

function getRange(id, direction) {
  const domElement = document.getElementById(id);
  const axis = domElement._fullLayout[direction + 'axis'];
  return axis.range
}

function axisEndAnnotations(id, layout) {

  let domElement = document.getElementById(id);
  var xaxis = domElement._fullLayout['xaxis'];
  let xrange = xaxis.range
  var yaxis = domElement._fullLayout['yaxis'];
  let yrange = yaxis.range

  console.log(last(xrange))
  console.log(last(getMinorTicks(id, 'x')))
  // Arrow heads and axis labels
  return annotations =
    [
      {
        text: '$\\Large x$',
        x: last(getMinorTicks(id, 'x')),
        y: -0.3,
        showarrow: false
      },
      {
        text: '', // Needed or else space between end and ax value set below.
        x: last(xrange),
        y: 0,
        ax: last(getMinorTicks(id, 'x')),
        ay: 0,

        xref: 'x',
        yref: 'y',
        axref: 'x',
        ayref: 'y',

        arrowwidth: 1,
        arrowsize: 2,
        arrowhead: 3,
        standoff: 0,
        arrowwidth: 1.1,
        arrowcolor: 'black',
        borderpad: 0,
        startstandoff: 0,
        showarrow: true
      },
      {
        text: '$\\Large y$',
        x: 0.2,
        y: last(getMinorTicks(id, 'y')),
        showarrow: false
      },
      {
        text: '', // Needed or else space between end and ay value set below.
        x: 0,
        y: last(yrange),
        ax: 0,
        ay: last(getMinorTicks(id, 'y')),
        xref: 'x',
        yref: 'y',
        axref: 'x',
        ayref: 'y',
        arrowwidth: 1,
        arrowsize: 2,
        arrowhead: 3,
        standoff: 0,
        arrowwidth: 1.1,
        arrowcolor: 'black',
        borderpad: 0,
        startstandoff: 0,
        showarrow: true
      }
    ]
}

function axisTicksAndLabels(id, layout, direction) {

  if (!direction) {
    const [annotationsx, shapesx] = axisTicksAndLabels(id, layout, 'x')
    const [annotationsy, shapesy] = axisTicksAndLabels(id, layout, 'y')
    return [[...annotationsx, ...annotationsy], [...shapesx, ...shapesy]]
  }

  const axisName = direction + 'axis'
  const domElement = document.getElementById(id);
  const _axis = domElement._fullLayout[axisName];

  const ticks = layout[axisName].ticks
  const showticklabels = layout[axisName].showticklabels

  const annotations = []
  const shapes = []

  if (ticks === '' && showticklabels === false) {
    log(`ticks = ${ticks}, showticklabels = ${showticklabels}. Returning.`, 'axisTicksAndLabels')
    return [annotations, shapes]
  }

  let c2pRatio = coordinateToPixelRatio(id, 'y')
  if (direction === 'x') {
  } else {
    c2pRatio = coordinateToPixelRatio(id, 'y')
  }

  let bottom = 0;
  let len = c2pRatio*(layout[axisName].ticklen)
  if (layout[axisName].ticks === 'inside') {
    bottom = 0;
  }
  if (layout[axisName].ticks === 'outside') {
    bottom = -c2pRatio*layout[axisName].ticklen;
  }
  if (layout[axisName].ticks === 'centered') {
    bottom = -c2pRatio*layout[axisName].ticklen/2;
  }

  const vals = getMajorTicks(id, direction)
  console.log(vals)
  for (let i = 0; i < vals.length; i++) {

    if (vals[i] === 0) continue

    if (layout[axisName].showticklabels !== false) {
      if (direction === 'x') {
        annotations.push({
          text: vals[i],
          x: vals[i] < 0 ? vals[i] - c2pRatio : vals[i],
          y: bottom,
          xanchor: "center",
          yanchor: "top",
          showarrow: false
        })
      } else {
        annotations.push({
          text: vals[i],
          font: layout[axisName].font,
          x: bottom,
          y: vals[i] < 0 ? vals[i] - c2pRatio : vals[i],
          xanchor: "right",
          yanchor: "left",
          showarrow: false
        })
      }
    }

    if (layout[axisName].ticks !== '') {
      if (direction === 'x') {
        shapes.push({
          type: 'line',
          x0: vals[i],
          y0: bottom,
          x1: vals[i],
          y1: bottom + len,
          line: {
            color: layout[axisName].tickcolor,
            width: layout[axisName].tickwidth,
            dash: 'solid'
          }
        })
      } else {
        shapes.push({
          type: 'line',
          x0: bottom,
          y0: vals[i],
          x1: bottom + len,
          y1: vals[i],
          line: {
            color: 'black',
            width: layout[axisName].tickwidth,
            dash: 'solid'
          }
        })
      }
    }
  }

  return [annotations, shapes]
}

function zeroLines(id, direction) {

  direction = 'y'
  const range = getRange(id, direction)
  log("range = " + range, 'zeroLines')

  const axisTraces = []
  if (direction === 'x') {
    axisTraces.push({
      x: [range[0], last(range)],
      y: [0, 0],
      showlegend: false,
      mode: 'lines',
      line: {
        color: 'black',
        width: 1,
        dash: 'solid'
      }
    })
  } else {
    axisTraces.push({
      x: [0, 0],
      y: [range[0], last(range)],
      showlegend: false,
      mode: 'lines',
      line: {
        color: 'black',
        width: 1,
        dash: 'solid'
      }
    })
  }
  return axisTraces
}

function gridLines(x, y, layout) {

  const gridTraces = []
  console.log(layout)
  let showMajorGrid = layout.xaxis.showgrid
  let showMinorGrid = layout.xaxis.minor.showgrid
  if (showMajorGrid === false && showMinorGrid === false) {
    return gridTraces
  }

  for (let i = 0; i < x.length; i++) {

    if (x[i] !== 0 && showMajorGrid === true) {
      //console.log("major: ", x[i])
      gridTraces.push({
        x: [x[i], x[i]],
        y: [y[0], y[y.length-1]],
        showlegend: false,
        mode: 'lines',
        line: {
          color: layout.xaxis.gridcolor,
          width: layout.xaxis.gridwidth,
          dash: layout.xaxis.griddash
        }
      })
    }

    if (showMinorGrid === false) {
      continue
    }

    xg = x[i] + layout.xaxis.minor.dtick
    while (xg < x[i+1]) {
      //console.log("minor: ", xg)
      gridTraces.push({
        x: [xg, xg],
        y: [y[0], y[y.length-1]],
        showlegend: false,
        mode: 'lines',
        line: {
          color: layout.xaxis.minor.gridcolor,
          width: layout.xaxis.minor.gridwidth,
          dash: layout.xaxis.minor.griddash
        }
      })
      xg += layout.xaxis.minor.dtick
    }
  }

  return gridTraces
}

function coordinateToPixelRatio(id, direction) {
  let domElement = document.getElementById(id);
  var axis = domElement._fullLayout[direction + 'axis'];
  let offset = 0;
  let c2pRatio = 0;

  log(`axis.c2p(axis.range[0]) = ${axis.c2p(axis.range[0])}`, 'coordinateToPixelRatio')
  log(`axis.c2p(last(axis.range)) = ${axis.c2p(last(axis.range))}`, 'coordinateToPixelRatio')
  if (direction === 'x') {
    offset = domElement._fullLayout.margin.l;
    c2pRatio = (axis.c2p(axis.range[0]) + offset) / (axis.c2p(last(axis.range)) + offset);
  }
  if (direction === 'y') {
    offset = domElement._fullLayout.margin.t;
    const dPixels = axis.c2p(axis.range[0]) - axis.c2p(last(axis.range))
    const dValues = last(axis.range) - axis.range[0];
    c2pRatio = dValues / dPixels
  }
  //const c2pRatio = (axis.c2p(last(axis.range)) + offset) / (axis.c2p(axis.range[0]) + offset);
  log(`direction = ${direction}, c2pRatio = ${c2pRatio}, offset = ${offset}`, 'coordinateToPixelRatio')

  return c2pRatio
}

function arange(start, step, step) {
  if (step === undefined) {
    return [...Array(start).keys()]
  } else {
    let x = []
    let val = start
    while (start < stop) {
      x.push(val)
      val += step
    }
    return x
  }
}

function plot(x, y, style, layout, config) {

  log('Called.','plot')

  if (!config) {
    config = timeseries.textbook.config;
  }
  if (!style) {
    style = timeseries.defaults.style.lines;
  }
  if (!layout) {
    layout = timeseries.textbook.layout;
  }
  if (layout.height === undefined) {
    layout.height = util.viewportWH().height;
  }

  data = [{x: x, y: y, ...style}]

  log('Calling Plotly.newPlot().','plot')
  Plotly.newPlot(gcf(), data, layout, config)
    .then(function(domElement) {
      log("Plotly.newPlot.then()",'plot')

      layoutOriginal = JSON.parse(JSON.stringify(layout))

      if (config._keepOriginalLayout === false) {
        const layoutMods = {
          xaxis: {
            zeroline: false,
            showgrid: false,
            showline: false,
            ticks: '',
            showticklabels: false,
            minor: {
              showgrid: false
            }
          }
        }
        layoutMods.yaxis = layoutMods.xaxis;

        layout = {...layout, ...layoutMods}
        Plotly.relayout(gcf(), layout)
      }

      // Number of traces before annotation traces are added
      let nTraces = domElement.data.length 

      // We don't use Plotly's zeroline because it will extend past the axis
      // arrow annotation. We add the zero lines after Plotly.newPlot() is
      // called because we need the axes ranges.
      //zeroLines = zeroLines(gcf(), layoutOriginal)
      //Plotly.addTraces(gcf(), zeroLines)

      // Need to set after newPlot() because range is needed.
      endAnnotations = axisEndAnnotations(gcf())

      // Need to set ticks and labels after Plotly.newPlot() so that
      // the coordinate to pixel ratios can be calculated.
      const [labelAnnotations, tickShapes] = axisTicksAndLabels(gcf(), layoutOriginal)
      console.log(labelAnnotations)
      layout = {}
      layout.annotations = [...endAnnotations, ...labelAnnotations]
      layout.shapes = tickShapes
      Plotly.relayout(gcf(), layout)

      //gridTraces = gridLines(x, y, layoutOriginal)
      //Plotly.addTraces(gcf(), gridTraces)

      // Move first trace to end so that it is behind the gridlines
      // https://plotly.com/javascript/plotlyjs-function-reference/
      Plotly.moveTraces(gcf(), arange(nTraces));

  })

  if (!config.staticPlot) {
    events.set(gcf())
  }
}

function figure() {}

function gcf() {
  return "plot0"
}
function gca() {
  return "plot0"
}
function keys(obj) {
  return Object.keys(obj)
}
function toJSON(obj, indent) {
  return JSON.stringify(obj, null, indent)
}
function get (id, key) {
  const domElement = document.getElementById(id)
  console.log(keys(domElement))
  return domElement.layout[key]
}
function set(id, layout) {
  const domElement = document.getElementById(id)
  Plotly.relayout(domElement, layout);
}

</script>