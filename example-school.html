<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <title>Timeseries.js</title>
  <script
    type="text/javascript"
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script> 
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="util.js"></script>
	<script src="timeseries.js"></script>
	<script src="log.js"></script>
	<script src="events.js"></script>
  <style>
    htm, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    div.plotly-notifier {
      visibility: hidden;
    }
  </style>
</head>

<body>
	<div id="plot0"/>
</body>

<script>
main()
function main() {
  const x = [-1, 0, 1, 2, 3, 4, 5];
  const y = [-1, 0, 1, 2, 3, 4, 5];
  const style = {name: 'name1', showlegend: false};
  plot(x, y, style)
}

function last(array) {
  return array[array.length - 1]
}

function getMajorTicks(id, direction) {
  const axisName = direction + 'axis'
  const domElement = document.getElementById(id);
  const _axis = domElement._fullLayout[axisName];

  let values = [];
  for (let _val of _axis._vals) {
    if (!_val.minor) values.push(_val.x)
  }
  return values
}

function getMinorTicks(id, direction) {
  const axisName = direction + 'axis'
  const domElement = document.getElementById(id);
  const _axis = domElement._fullLayout[axisName];

  let values = [];
  for (let _val of _axis._vals) {
    if (_val.minor) values.push(_val.x)
  }
  return values
}

function getRange(id, direction) {
  const domElement = document.getElementById(id);
  const axis = domElement._fullLayout[direction + 'axis'];
  return axis.range
}

function coordinateToPixelRatio(id, direction) {
  let domElement = document.getElementById(id);
  var axis = domElement._fullLayout[direction + 'axis'];
  let offset = 0;
  let c2pRatio = 0;

  log(`axis.range[0] = ${axis.range[0]}`, 'coordinateToPixelRatio')
  log(`last(axis.range) = ${last(axis.range)}`, 'coordinateToPixelRatio')
  log(`axis.c2p(axis.range[0]) = ${axis.c2p(axis.range[0])}`, 'coordinateToPixelRatio')
  log(`axis.c2p(last(axis.range)) = ${axis.c2p(last(axis.range))}`, 'coordinateToPixelRatio')
  const dPixels = axis.c2p(last(axis.range)) - axis.c2p(axis.range[0])
  const dValues = last(axis.range) - axis.range[0];
  log(`dValues = ${dValues}`, 'coordinateToPixelRatio')
  log(`dPixels = ${dPixels}`, 'coordinateToPixelRatio')
  if (direction === 'x') {
    offset = domElement._fullLayout.margin.l;
    //c2pRatio = (axis.c2p(axis.range[0]) + offset) / (axis.c2p(last(axis.range)) + offset);
    c2pRatio = dValues / dPixels
  }
  if (direction === 'y') {
    //offset = domElement._fullLayout.margin.t;
    c2pRatio = -dValues / dPixels
  }
  //const c2pRatio = (axis.c2p(last(axis.range)) + offset) / (axis.c2p(axis.range[0]) + offset);
  log(`direction = ${direction}, c2pRatio = ${c2pRatio}, offset = ${offset}`, 'coordinateToPixelRatio')

  return c2pRatio
}

function axisAnnotations(id, dataRange) {

  let domElement = document.getElementById(id);
  let xrange = domElement._fullLayout['xaxis'].range;
  let yrange = domElement._fullLayout['yaxis'].range;

  // Arrow heads and axis labels
  return annotations =
    [
      {
        text: '$\\Large x$',
        x: last(getMinorTicks(id, 'x')),
        y: -coordinateToPixelRatio(id, 'y')*16,
        showarrow: false,
      },
      {
        text: '', // Needed or else space between end and ax value set below.
        x: last(getMinorTicks(id, 'x')),
        y: 0,
        ax: xrange[0] < 0 && dataRange.x[0] >= 0 ? 0 : dataRange.x[0],
        ay: 0,

        xref: 'x',
        yref: 'y',
        axref: 'x',
        ayref: 'y',

        arrowwidth: 1,
        arrowsize: 2,
        arrowhead: 3,
        standoff: 0,
        arrowwidth: 1.1,
        arrowcolor: 'black',
        borderpad: 0,
        startstandoff: 0,
        showarrow: true
      },
      {
        text: '$\\Large y$',
        x: coordinateToPixelRatio(id, 'x')*16,
        y: last(getMinorTicks(id, 'y')),
        showarrow: false
      },
      {
        text: '', // Needed or else space between end and ay value set below.
        x: 0,
        y: last(getMinorTicks(id, 'y')),
        ax: 0,
        ay: yrange[0] < 0 && dataRange.y[0] >= 0 ? 0 : dataRange.y[0],
        xref: 'x',
        yref: 'y',
        axref: 'x',
        ayref: 'y',
        arrowwidth: 1,
        arrowsize: 2,
        arrowhead: 3,
        standoff: 0,
        arrowwidth: 1.1,
        arrowcolor: 'black',
        borderpad: 0,
        startstandoff: 0,
        showarrow: true
      }
    ]
}

function axisTicksAndLabels(id, layout, direction) {

  if (!direction) {
    const [annotationsx, shapesx] = axisTicksAndLabels(id, layout, 'x')
    const [annotationsy, shapesy] = axisTicksAndLabels(id, layout, 'y')
    return [[...annotationsx, ...annotationsy], [...shapesx, ...shapesy]]
  }

  const axisName = direction + 'axis'
  const domElement = document.getElementById(id);
  const _axis = domElement._fullLayout[axisName];

  const ticks = layout[axisName].ticks
  const showticklabels = layout[axisName].showticklabels

  const annotations = []
  const shapes = []

  if (ticks === '' && showticklabels === false) {
    log(`ticks = ${ticks}, showticklabels = ${showticklabels}. Returning.`, 'axisTicksAndLabels')
    return [annotations, shapes]
  }

  let c2pRatio = coordinateToPixelRatio(id, 'y')
  if (direction === 'x') {
  } else {
    c2pRatio = coordinateToPixelRatio(id, 'y')
  }

  let bottom = 0;
  let len = c2pRatio*(layout[axisName].ticklen)
  if (layout[axisName].ticks === 'inside') {
    bottom = 0;
  }
  if (layout[axisName].ticks === 'outside') {
    bottom = -c2pRatio*layout[axisName].ticklen;
  }
  if (layout[axisName].ticks === 'centered') {
    bottom = -c2pRatio*layout[axisName].ticklen/2;
  }

  const vals = getMajorTicks(id, direction)
  for (let i = 0; i < vals.length; i++) {

    if (vals[i] === 0) continue

    if (layout[axisName].showticklabels !== false) {
      if (direction === 'x') {
        annotations.push({
          text: vals[i],
          x: vals[i] < 0 ? vals[i] - c2pRatio : vals[i],
          y: bottom,
          xanchor: "center",
          yanchor: "top",
          showarrow: false
        })
      } else {
        annotations.push({
          text: vals[i],
          font: layout[axisName].font,
          x: bottom,
          y: vals[i] < 0 ? vals[i] - c2pRatio : vals[i],
          xanchor: "right",
          yanchor: "left",
          showarrow: false
        })
      }
    }

    if (layout[axisName].ticks !== '') {
      if (direction === 'x') {
        shapes.push({
          type: 'line',
          x0: 0,
          y0: -layout[axisName].ticklen/2,
          x1: 0,
          y1: layout[axisName].ticklen/2,
          xanchor: vals[i],
          yanchor: 0,
          xsizemode: 'pixel',
          ysizemode: 'pixel',
          line: {
            color: layout[axisName].tickcolor,
            width: layout[axisName].tickwidth,
            dash: 'solid'
          }
        })
      } else {
        shapes.push({
          type: 'line',
          x0: -layout[axisName].ticklen/2,
          y0: 0,
          x1: layout[axisName].ticklen/2,
          y1: 0,
          xanchor: 0,
          yanchor: vals[i],
          xsizemode: 'pixel',
          ysizemode: 'pixel',
          line: {
            color: 'black',
            width: layout[axisName].tickwidth,
            dash: 'solid'
          }
        })
      }
    }
  }

  return [annotations, shapes]
}

function gridLines(id, dataRange, layout, direction) {

  if (!direction) {
    const gridTracesx = gridLines(id, dataRange, layout, 'x')
    const gridTracesy = gridLines(id, dataRange, layout, 'y')
    return [...gridTracesx, ...gridTracesy]
  }

  const axisName = direction + 'axis'
  const gridTraces = []
  let showMajorGrid = layout[axisName].showgrid
  let showMinorGrid = layout[axisName].minor.showgrid
  if (showMajorGrid === false && showMinorGrid === false) {
    return gridTraces
  }

  let xMajor = getMajorTicks(id, 'x');
  let yMajor = getMajorTicks(id, 'y');
  let xMinor = getMinorTicks(id, 'x');
  let yMinor = getMinorTicks(id, 'y');
  const minX = dataRange.x[0]
  const maxX = dataRange.x[1]
  const minY = dataRange.y[0]
  const maxY = dataRange.y[1]

  if (showMajorGrid) {
    let attribs = {
      showlegend: false,
      mode: 'lines',
      hoverinfo: 'skip',
      line: {
        color: layout[axisName].gridcolor,
        width: layout[axisName].gridwidth,
        dash: layout[axisName].griddash
      }
    }
    if (direction === 'x') {
      for (let i = 0; i < xMajor.length; i++) {
        if (xMajor[i] !== 0 && xMajor[i] >= minX && xMajor[i] <= maxX) {
          //console.log("major: ", xMajor[i])
          gridTraces.push({
            x: [xMajor[i], xMajor[i]],
            y: [minY, maxY],
            ...attribs
          })
        }
      }
    }
    if (direction === 'y') {
      for (let i = 0; i < yMajor.length; i++) {
        if (yMajor[i] !== 0 && yMajor[i] >= minY && yMajor[i] <= maxY) {
          //console.log("major: ", yMajor[i])
          gridTraces.push({
            x: [minX, maxX],
            y: [yMajor[i], yMajor[i]],
            ...attribs
          })
        }
      }
    }
  }

  if (showMinorGrid) {
    let attribs = {
      showlegend: false,
      mode: 'lines',
      hoverinfo: 'skip',
      line: {
        color: layout[axisName].minor.gridcolor,
        width: layout[axisName].minor.gridwidth,
        dash: layout[axisName].minor.griddash
      }
    }
    if (direction === 'x') {
      for (let i = 0; i < xMinor.length; i++) {
        if (xMinor[i] !== 0 && xMinor[i] >= minX && xMinor[i] <= maxX) {
          //console.log("minor: ", xMinor[i])
          gridTraces.push({
            x: [xMinor[i], xMinor[i]],
            y: [minY, maxY],
            ...attribs
          })
        }
      }
    }
    if (direction === 'y') {
      for (let i = 0; i < yMinor.length; i++) {
        if (yMinor[i] !== 0 && yMinor[i] >= minY && yMinor[i] <= maxY) {
          //console.log("minor: ", yMinor[i])
          gridTraces.push({
            x: [minY, maxY],
            y: [yMinor[i], yMinor[i]],
            ...attribs
          })
        }
      }
    }
  }

  return gridTraces
}

function arange(start, step, step) {
  if (step === undefined) {
    return [...Array(start).keys()]
  } else {
    let x = []
    let val = start
    while (start < stop) {
      x.push(val)
      val += step
    }
    return x
  }
}

function plot(x, y, style, layout, config) {

  log('Called.','plot')

  if (!config) {
    config = timeseries.textbook.config;
  }
  if (!style) {
    style = timeseries.defaults.style.lines;
  }
  if (!layout) {
    layout = timeseries.textbook.layout;
  }
  if (layout.height === undefined) {
    layout.height = util.viewportWH().height;
  }

  data = [{x: x, y: y, ...style}]

  log('Calling Plotly.newPlot().','plot')
  Plotly.newPlot(gcf(), data, layout, config)
    .then(function(domElement) {
      log("Plotly.newPlot.then()",'plot')

      log('fullLayout after initial render:', 'plot')
      log(domElement._fullLayout,'plot')

      // Number of traces before annotation traces are added
      let nTraces = domElement.data.length 

      // We don't use Plotly's zeroline because it will extend past the axis
      // arrow annotation. We add the zero lines after Plotly.newPlot() is
      // called because we need the axes ranges.
      //zeroLines = zeroLines(gcf(), layoutOriginal)
      //Plotly.addTraces(gcf(), zeroLines)

      const dataRange = {
        x: [Math.min(...x), Math.max(...x)],
        y: [Math.min(...y), Math.max(...y)]
      }

      if (config._useOriginalGridLines === false) {
        const gridTraces = gridLines(gcf(), dataRange, layout)
        Plotly.addTraces(gcf(), gridTraces)
      }

      // Need to set after newPlot() because range is needed.
      const endAnnotations = axisAnnotations(gcf(), dataRange)

      // Need to set ticks and labels after Plotly.newPlot() so that
      // the coordinate to pixel ratios can be calculated.
      const [labelAnnotations, tickShapes] = axisTicksAndLabels(gcf(), layout)

      layout = {}
      layout.annotations = [...endAnnotations, ...labelAnnotations]
      layout.shapes = tickShapes

      if (config._keepOriginalLayout === false) {
        const layoutMods = {
          xaxis: {
            zeroline: false,
            showgrid: config._useOriginalGridLines,
            showline: false,
            ticks: '',
            showticklabels: false,
            minor: {
              showgrid: config._useOriginalGridLines
            }
          }
        }
        layoutMods.yaxis = layoutMods.xaxis;
        layout = {...layout, ...layoutMods}
      }
      Plotly.relayout(gcf(), layout)

      // Move first trace to end so that it is behind the gridlines
      // https://plotly.com/javascript/plotlyjs-function-reference/
      Plotly.moveTraces(gcf(), arange(nTraces));

  })

  if (!config.staticPlot) {
    events.set(gcf())
  }
}

function figure() {}

function gcf() {
  return "plot0"
}
function gca() {
  return "plot0"
}
function keys(obj) {
  return Object.keys(obj)
}
function toJSON(obj, indent) {
  return JSON.stringify(obj, null, indent)
}
function get (id, key) {
  const domElement = document.getElementById(id)
  console.log(keys(domElement))
  return domElement.layout[key]
}
function set(id, layout) {
  const domElement = document.getElementById(id)
  Plotly.relayout(domElement, layout);
}

</script>