<!DOCTYPE html>
<head>
	<title>Timeseries.js</title>
  <script
    type="text/javascript"
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script> 
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="util.js"></script>
	<script src="timeseries.js"></script>
	<script src="log.js"></script>
	<script src="events.js"></script>
  <style>
    htm, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    div.plotly-notifier {
      visibility: hidden;
    }
  </style>
</head>

<body>
	<div id="plot0"/>
</body>

<script>
const x = [-2, -1, 0, 1, 2, 3, 4, 5];
const y = x;

plot(x, y)

function last(array) {
  return array[array.length - 1]
}

function axisEndAnnotations(id) {

  let domElement = document.getElementById(id);
  var xaxis = domElement._fullLayout['xaxis'];
  let xrange = xaxis.range
  var yaxis = domElement._fullLayout['yaxis'];
  let yrange = yaxis.range

  // Arrow heads and axis labels
  return annotations =
    [
      {
        text: '$\\Large x$',
        x: 5.2,
        y: -0.2,
        showarrow: false
      },
      {
        x: 5.4,
        y: 0,
        xref: 'x',
        yref: 'y',
        axref: 'x',
        ayref: 'y',
        ax: 0,
        ay: 0,
        xshift: 0, // why needed?
        arrowwidth: 1,
        arrowsize: 3,
        standoff: 0,
        arrowwidth: 1.1,
        arrowcolor: 'black',
        borderpad: 0,
        startstandoff: 0,
        //height: 16, // Fixes an off-by-one pixel error
        //valign: 'top', // Fixes an off-by-one pixel error
        showarrow: true
      },
      {
        text: '$\\Large y$',
        x: 0.15,
        y: last(yrange),
        showarrow: false
      },
      {
        text: '&#9650;',
        x: 0,
        y: last(yrange),
        showarrow: false
      }
    ]

  //layout.annotations = [...layout.annotations, ...annotations]
}

function CoordinateToPixelRatio(id, direction) {
  let domElement = document.getElementById(id);
  var axis = domElement._fullLayout[direction + 'axis'];
  let offset = 0;
  if (direction == 'x') {
    offset = domElement._fullLayout.margin.l;
  }
  if (direction == 'y') {
    offset = domElement._fullLayout.margin.t;
  }
  const c2pRatio = (axis.c2p(axis.range[0]) + offset) / (axis.c2p(last(axis.range)) + offset);
  return c2pRatio
}

function axisTicksAndLabels(id, layout) {

  let domElement = document.getElementById(id);
  var xaxis = domElement._fullLayout['xaxis'];
  let xrange = xaxis.range
  console.log(xaxis)
  //return
  //let ticks = layout.xaxis.ticks
  //layout.xaxis.ticks = '' // Disable Plotly's ticks

  //let showticklabels = layout.xaxis.showticklabels
  //layout.xaxis.showticklabels = false // Disable Plotly's ticklabels

  //if (ticks === '' && showticklabels === false) return

  let c2pRatioX = CoordinateToPixelRatio(id, 'x')

  if (!layout.annotations) {
    layout.annotations = []
  }
  if (!layout.shapes) {
    layout.shapes = []
  }
  let bottom = 0;

  // Plotly uses half the tick length for the length of the tick. Why?
  let len = c2pRatioX*(layout.xaxis.ticklen/2)
  if (xaxis.ticks === 'outside') {
    bottom = -c2pRatioX*xaxis.ticklen/2;
  }
  if (xaxis.ticks === 'inside') {
    bottom = 0;
  }
  if (layout.xaxis.ticks === 'centered') {
    bottom = -c2pRatioX*xaxis.ticklen/2;
    len = 2*len
  }

  let x = [];
  console.log(xaxis._vals)
  for (let val of xaxis._vals) {
    if (!val.minor)
      x.push(val.x)
  }
  console.log(x)
  for (let i = 0; i < x.length; i++) {

    if (x[i] === 0) continue

    if (xaxis.showticklabels !== false) {
      layout.annotations.push({
        text: x[i],
        x: x[i] < 0 ? x[i] - c2pRatioX : x[i],
        y: bottom,
        xanchor: "center",
        yanchor: "top",
        showarrow: false
      })
    }

    if (xaxis.ticks !== '') {
      layout.shapes.push({
        type: 'line',
        x0: x[i],
        y0: bottom,
        x1: x[i],
        y1: bottom + len,
        line: {
          color: 'black',
          width: 1,
          dash: 'solid'
        }
      })
    }
  }

}

function zeroLines(id,range) {

  const axisTraces = []
  axisTraces.push({
    x: [range[0], last(range)],
    y: [0, 0],
    showlegend: false,
    mode: 'lines',
    line: {
      color: 'black',
      width: 1,
      dash: 'solid'
    }
  })
  return axisTraces
}

function gridLines(x, y, layout) {

  const gridTraces = []

  let showMajorGrid = layout.xaxis.showgrid
  let showMinorGrid = layout.xaxis.minor.showgrid
  layout.xaxis.showgrid = false // Disable Plotly's gridlines
  layout.xaxis.minor.showgrid = false // Disable Plotly's gridlines
  if (showMajorGrid === false && showMinorGrid === false) {
    return gridTraces
  }

  for (let i = 0; i < x.length; i++) {

    if (x[i] !== 0 && showMajorGrid === true) {
      //console.log("major: ", x[i])
      gridTraces.push({
        x: [x[i], x[i]],
        y: [y[0], y[y.length-1]],
        showlegend: false,
        mode: 'lines',
        line: {
          color: layout.xaxis.gridcolor,
          width: layout.xaxis.gridwidth,
          dash: layout.xaxis.griddash
        }
      })
    }

    if (showMinorGrid === false) {
      continue
    }

    xg = x[i] + layout.xaxis.minor.dtick
    while (xg < x[i+1]) {
      //console.log("minor: ", xg)
      gridTraces.push({
        x: [xg, xg],
        y: [y[0], y[y.length-1]],
        showlegend: false,
        mode: 'lines',
        line: {
          color: layout.xaxis.minor.gridcolor,
          width: layout.xaxis.minor.gridwidth,
          dash: layout.xaxis.minor.griddash
        }
      })
      xg += layout.xaxis.minor.dtick
    }
  }

  return gridTraces
}

function arange(start, step, step) {
  if (step === undefined) {
    return [...Array(start).keys()]
  } else {
    let x = []
    let val = start
    while (start < stop) {
      x.push(val)
      val += step
    }
    return x
  }
}

function plot(x, y, style, layout, config) {

  if (!config) {
    config = timeseries.textbook.config;
  }
  if (!style) {
    style = timeseries.defaults.style.lines;
  }
  if (!layout) {
    layout = timeseries.textbook.layout;
  }
  if (layout.height === undefined) {
    layout.height = util.viewportWH().height;
  }
  if (layout.annotations === undefined) {
    layout.annotations = []
  }
  if (layout.shapes === undefined) {
    layout.shapes = []
  }

  data = [{x: [-2, 5], y: [-2, 5], name: 'name1', showlegend: false, ...style}]


  Plotly.newPlot(gcf(), data, layout, config)
    .then(function() {

      console.log("plotly.newPlot.then()")

      let domElement = document.getElementById(gcf());

      // Number of traces before annotation traces are added
      let nTraces = domElement.data.length 

      var axis = domElement._fullLayout['xaxis'];
      let range = axis.range
      console.log("range = ", range)

      // We don't use Plotly's zeroline because it will extend past the axis
      // arrow annotation. We add the zero lines after Plotly.newPlot() is
      // called because we need the axes ranges.
      if (layout.yaxis.zeroline === true) {
        yzeroline = true;
      }
      layout.yaxis.zeroline = false // Disable Plotly's zeroline

      if (yzeroline) {
        zeroLines = zeroLines(gcf(), range)
        Plotly.addTraces(gcf(), zeroLines)
      }
      Plotly.relayout(domElement, layout);

      // Need to set after newPlot() because range is needed.
      layout.annotations = axisEndAnnotations(gcf())
      Plotly.relayout(domElement, layout);

      // Need to set ticks and labels after Plotly.newPlot so that
      // the coordinate to pixel ratios can be calculated.
      axisTicksAndLabels(gcf(), layout)

      gridTraces = gridLines(x, y, layout)
      Plotly.addTraces(gcf(), gridTraces)

      // Move first trace to end so that it is behind the gridlines
      // https://plotly.com/javascript/plotlyjs-function-reference/
      Plotly.moveTraces(gcf(), arange(nTraces));

  })

  if (!config.staticPlot) {
    events.set(gcf())
  }
}

function figure() {}

function gcf() {
  return "plot0"
}
function gca() {
  return "plot0"
}
function keys(obj) {
  return Object.keys(obj)
}
function toJSON(obj, indent) {
  return JSON.stringify(obj, null, indent)
}
function get (id, key) {
  const domElement = document.getElementById(id)
  console.log(keys(domElement))
  return domElement.layout[key]
}
function set(id, layout) {
  const domElement = document.getElementById(id)
  Plotly.relayout(domElement, layout);
}

</script>